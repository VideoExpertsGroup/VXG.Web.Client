/* ATTENTION: Do not edit this file for no good reason!!!. This is a kernel file, and the performance of the entire system depends on its contents. */

window.vxg = window.vxg || {};
vxg.user = vxg.user || {};
vxg.users = vxg.users || {};
vxg.users.objects = vxg.users.objects || {};


//////////////////////////////////////////////////
// Errors
vxg.links = vxg.links || {
error: 'https://home.bluemonitor.net/documentation/'
}
//////////////////////////////////////////////////
// User api

vxg.user.getToken = function(){
    if (!window.firebase)
        return new Promise(function(resolve, reject){setTimeout(function(){reject();}, 0);});
    return Promise.resolve(firebase.auth().currentUser.getIdToken());
}

vxg.user.getUsedPlans = function(){
    return vxg.api.necam.user.getUsedPlans().then(function(r){
        return r.data;
    });
}

//////////////////////////////////////////////////
// User list functions

vxg.users.objects.User = function(src){
    this.src = src;
}

vxg.users.invalidate = function(){
    this.expired = 0;
    this.list = [];
}

vxg.users.getList = function(limit, offset){
    let self = this;
    let args = {};
    this.list = this.list || [];
    if (limit!==undefined) args.limit = limit;
    if (offset!==undefined) args.offset = offset;
    return vxg.api.necam.user.list(args).then(function(r){
        if (typeof r === "string")
            return new Promise(function(resolve, reject){setTimeout(function(){reject();}, 0);});

        self.total_count = r.total;
        self.expired = Date.now() + self.update_delay*1000;
        let ret = [];
        for (let i in r.data){
            self.list[r.data[i].id] = new vxg.users.objects.User(r.data[i]);
            ret.push(self.list[r.data[i].id]);
        }
        return ret;
    },function(r){
        
    });
}

vxg.users.getUserByID = function(userid){
    return this.list[userid];
}

////////////////////////////////////////////////
// Camera object extent

NecamCamera = {}

if (!vxg.cameras.objects.Camera) {
    vxg.cameras.objects.Camera = function(){}
    vxg.cameras.objects.Camera.prototype = NecamCamera;
} else {
    NecamCamera.__proto__ = vxg.cameras.objects.Camera.prototype;
    vxg.cameras.objects.Camera.prototype = NecamCamera;
}

NecamCamera.setLocation = function(location){
    return vxg.api.necam.camera.setLocations(this.camera_id, location);
}

/*
url
tz
name
location
lat
lon
desc
username 
password 
onvifRtspPort
isRecording
*/

NecamCamera.getConfig = function(){
    let self = this;
    if (this.bsrc)
        return new Promise(function(resolve, reject){setTimeout(function(){resolve(self.bsrc)}, 0);});
    if (NecamCamera.getConfig.promise) return NecamCamera.getConfig.promise.then(function(){
        if (self.bsrc)
            return self.bsrc;
    });
/*
    let ch = [];
    for (i in vxg.cameras.random_list)
        if (!vxg.cameras.random_list[i].bsrc)
            ch.push(vxg.cameras.random_list[i].camera_id);
*/
    NecamCamera.getConfig.promise = vxg.api.necam.camera.list({channelID:self.camera_id, limit:100, offset:0}).then(function(r){
        delete NecamCamera.getConfig.promise;
        for (let i=0;i<r.data.length;i++)
            vxg.cameras.random_list[r.data[i].channelID].bsrc = r.data[i];
        if (self.bsrc)
            return self.bsrc;
    });
    return NecamCamera.getConfig.promise;
}

NecamCamera.getLocation = function(){
    if (this.bsrc && this.bsrc.location) return this.bsrc.location;
    return '';
}

/**
 * Update camera.
 * Sample of use:
 *
 * vxg.cameras.updateCameraPromise({name: "New name"}).then(function(cam_object){
 *   console.log(cam_object;
 * });
 */

/*
NecamCamera.updateCameraPromise2 = function(camera_struct){
    let self = this;
    // Call updateCameraPromise from Necam object
    return this.__proto__.__proto__.updateCameraPromise.apply(this, [camera_struct]).then(function(){
        return self.setLocation(camera_struct['location']);
    });
}
*/

NecamCamera.updateCameraPromise = function(camera_struct){
    if (camera_struct===this.camera){
        console.error('Do not use the same object - use only copy. Sample: camera = JSON.parse(JSON.stringify(camera))');
        return;
    }
    camera_struct.cameraID = this.camera_id;
    return vxg.api.necam.camera.update(camera_struct).then(function(){
        window.vxg.cameras.invalidate();
    });
      return vxg.api.necam.user.camera.add(obj);
};

/**
 * Delete camera.
 * Sample of use:
 *
 * vxg.cameras.getCameraByIDPromise(214531).then(function(cam_object){
 *   cam_object.deleteCameraPromise();
 * });
 */
NecamCamera.deleteCameraPromise = function(){
    return vxg.api.necam.camera.del(this.camera_id).then(function(r){
        window.vxg.cameras.invalidate();
        return r;
    });
};

NecamCamera.setPlans = function(plan_id){
    let self = this;
    let _plan_id = plan_id;
//      if (plan_id==this.bsrc.planID) return defaultPromise();
    return vxg.api.necam.camera.setPlans({id:this.camera_id,planid:plan_id}).then(function(r){
        window.vxg.cameras.invalidate();
        return r;
    });
}

vxg.cameras.createCameraPromise = function(camera_struct/* = {name: "no name", mode: "off", rec_mode: "off", rec_status: "off", timezone: "UTC"}*/){
    return vxg.api.necam.camera.add(camera_struct).then(function(r){
        vxg.cameras.invalidate();
        return r;
    });
}

vxg.cameras.getCameraByIDPromise = function(camera_id, camtoken){
    let _camera_id = parseInt(camera_id);
    if (vxg.cameras.getCameraByIDPromise.promises && vxg.cameras.getCameraByIDPromise.promises[_camera_id])
        return vxg.cameras.getCameraByIDPromise.promises[_camera_id];
    let camera = vxg.cameras.random_list[_camera_id];
    if (camera!==undefined /*&& camera._last_update_utc + vxg.cameras.update_delay*1000 > Date.now()*/) {
        let ret = new Promise(function(resolve, reject){this.timer_id = setTimeout(function(){resolve(camera);}, 0);});
        ret.cancel = function(){if (this.timer_id) clearTimeout(this.timer_id);};
        return ret;
    }
    return vxg.api.necam.camera.list({channelID:_camera_id}).then(function(r){
        if (!r || !r.data || !r.data.length)
            return new Promise(function(resolve, reject){setTimeout(function(){reject();}, 0);});
        vxg.cameras.random_list[r.data[0].channelID] = new vxg.cameras.objects.Camera(r.data[0].token ? r.data[0].token : r.data[0].channelID);
        vxg.cameras.random_list[r.data[0].channelID].src = r.data[0];

//        if (!is_exist) vxg.cameras.random_list[r.objects[i].id]._last_limit_update_utc = 0;
        vxg.cameras.random_list[r.data[0].channelID]._last_update_utc = Date.now();
        return vxg.cameras.random_list[r.data[0].channelID];
    });

    return new Promise(function(resolve, reject){setTimeout(function(){resolve();}, 0);});
}